#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *
import math
from sympy import factorint, gcd, isprime, invert

# ------------------------------------------------------------------------------
# 문제에서 제공된 상수들
# ------------------------------------------------------------------------------
c0 = 815188129004593690
c1 = 127925291615994657581931619146695269807090069321028068300026702785628490435087413298680092490257386473119689267569976305630148807575684825719646470673354518537583693756638610236703360575725390523075157347945650329643185755019374721283312409555437073732909098741047201773844526561647418227464551267229483364364787507813737149585117565634566192141414340259600731010898093526776126496041547237731611641645486484003184145020567881814736379969229029494635289881135938616525514478902350456632528118064943796968955206904548914444880294647813769276998813113219946458705248043346165647674144729512746228364422970492090341913955974680328429531371057246002643999064173272750228905488785306922291142352536443928185480992771540164041351189897263855717835200997174303403999921094709386555246470299674355058943232903678863339196093611888915090594863104904225697723818302850752252778621729255567862244645828296741411364052759345927008961382069718216739397512177938134054358858778504307167668875379987274830574712603824004594928740077761311104953146589024383734236839245668317380100215644546947907324757631546712895527026941128733402210258099040798244092233062921213678241433301492159422755411303594795618110694805740300672599304274581599355787281881473140136530753285
c2 = 104454128536114134666041330893412849924539319238173846030358370053912259066553198144201647771409151179389296499444225182922737580937571253329036303241246786394696273703737240494606350619424942154134043974057071462964750990605316877522861478098457922126670980711982715700886739488588258928454751146720846461285104408526738717417461756044249496795236713285815410740335507214955619176318929380672905570604946736070454970829122165657529519191829096299562653289959758115282220314539044233440940890830246113981226775616062418119272940675413756550528704261381830683804964448149613789234326868825958311202712158979318207791357868949882157781068305218079123962336473944242076822566261833638654949217602001305205868861207596016799305223552788863815955231724125485952140180911558328890683991762828843660578236671443539626857037266048369875048432191608492096923173890923193063698396903093080818130375913491435899432596884306387277070900092571026594195475769816837963280460673050909448174467601579491721191905742242149320815840931148597139521486968369237822382185925961430998718690684270284663782612688833325942954176755873192287461806363161966656749124978838440843037636615696962613067946478062682619739085469224316287147692903237078068956379036902948739451784308
c3 = 287293965964521577536949600465877039412983676330501517864975724662075373903418313335625721299388975721491357903306320184247853204477040142941778760057485916689064629860222657837690248122034022696608633347098541733229160810131864253603149064874701423636836348322909135954798560398776651665237804954916116590130313684752444052866519034694526102201271444707642449670451542864865493541141728546221679654661093081848121118684594168895062943920921063566925549212250270641028144352434459819122102852072762780335391277683962786782857084040582699842796641523261150308932398544110620418151887847658837961044285094404774616962577265970393150696357457400719726381090518685568644813512490876890790663593699326420593277088351600861395830498853994952245899881834621106473224692036187989636146643992437367194572335837111809655664187790935259739926115874944166340456171845363032300979740488782920318711668046034568790879401209465850491455677846746238706089490902017942125993304620807882387410264371825909245185927481186838760450566656551893404361562801495420174484277284394683958112760663980049171039021132584343301267863299152953512497843386144751245181609419591873712505993146385725244308823894723973026051800808472848805433371109206822668160634407950261536850484088

# ------------------------------------------------------------------------------
# 아래 메시지들을 모듈러 없이 그냥 e=65537 거듭제곱(C2, C3) 후, n으로 나눈 나머지가 c2, c3.
# n = gcd( C2 - c2, C3 - c3 )
# ------------------------------------------------------------------------------
e = 0x10001

m2 = b"Lorem Ipsum is simply dummy text of"
m3 = b"the printing and typesetting industry"

m2_int = int.from_bytes(m2, 'big')
m3_int = int.from_bytes(m3, 'big')

C2 = pow(m2_int, e)  # 모듈러 없이 거듭제곱
C3 = pow(m3_int, e)

# ------------------------------------------------------------------------------
# step 1) n = gcd( C2 - c2, C3 - c3 )
# ------------------------------------------------------------------------------
n = gcd(C2 - c2, C3 - c3)
log.info(f"[1] n recovered = {n}")

# ------------------------------------------------------------------------------
# step 2) c0 = u1^2 + u2^2 => (u1, u2) 찾기
#          실제 큰 수면 Gauss 정수 인수분해가 필요.
#          여기서는 sympy의 factorint 결과를 기반으로 x^2 + y^2 꼴 분해를 시도한다.
# ------------------------------------------------------------------------------
c0_factors = factorint(c0)  # 딕셔너리 {소인수: 지수} 형태

# x^2 + y^2 꼴로 만들기 위한 헬퍼 함수(소인수들을 1 mod 4 형태로 쪼개기)
def decompose_sum_of_squares(n_factors: dict):
    """
    n_factors: sympy.factorint 결과.
    (x, y) 중 하나를 반환(절댓값). 여러 개면 임의로 하나를 반환하는 예시.
    
    - 실제로는 x^2 + y^2 로 유일(또는 거의 유일)하게 표현되지 않을 수도 있고,
      소인수 중 3 mod 4 형태가 있으면 x^2 + y^2 형태 불가능.
    """
    # 1) 각 소인수를 x^2 + y^2 꼴로 분해 (소수 p ≡ 1 (mod 4) 일 때 가능)
    # 2) 곱셈 시 x^2 + y^2 형식을 합치는 루틴( (x1^2+y1^2)(x2^2+y2^2) = ... ) 을 이용
    x_total, y_total = 1, 0
    
    for prime, exp in n_factors.items():
        # prime^exp 를 x^2 + y^2 꼴로 변환 누적
        if prime % 4 == 3 and exp % 2 != 0:
            # 3 mod 4 꼴 소수가 홀수 지수면 x^2 + y^2 불가능
            raise ValueError("c0 cannot be expressed as x^2+y^2 uniquely under this factor set.")
        
        # prime ≡ 1 mod 4 이면, 그 소수를 x'^2 + y'^2 로 표현
        # sympy 내장 함수: prime의 x^2+y^2 분해를 자동화하는 건 따로 없으므로
        # 작으면 직접 찾고, 크면 Gauss 정수 인수분해 등...
        # 여기선 prime이 작다고 가정(실제로는 큰 수도 있음) → 데모용
        
        # (1) 소수 p ≡ 1 mod 4에 대해서는 (a^2 + b^2) 형태가 존재
        #     a, b 찾기 (예시: 브루트포스 or 확장 알고리즘)
        
        # 여기서는 'prime이 매우 클 수도 있다'는 점을 감안하면
        #     => 실제로는 Sage 등으로 Gauss 정수 인수분해해야 함.
        # 여기선 간단 예시로 "브루트포스 함수" 형태만 포매팅.
        
        def find_ab_for_prime(p):
            # 매우 단순화된 예시(소수가 작다고 가정)
            # 실제로는 p가 매우 크다면 불가능하므로
            # Gauss 정수 인수분해 루틴 써야 함.
            limit = int(p**0.5)+1
            for a in range(limit):
                b_sq = p - a*a
                if b_sq < 0:
                    break
                b = int(math.isqrt(b_sq))
                if b*b == b_sq:
                    return (a, b)
            return None
        
        if prime == 2:
            # 2 = 1^2 + 1^2
            base_x, base_y = 1, 1
        else:
            # 실제 큰 소수라면 여기가 문제. 데모용으로 처리.
            # prime ≡ 1 mod 4 라고 가정
            ab = find_ab_for_prime(prime)
            if ab is None:
                raise ValueError(f"Failed to find x^2+y^2 for prime={prime}")
            base_x, base_y = ab
        
        # prime^exp = (base_x + i base_y)^exp
        # 여기서는 exp번 곱할 때마다 (x^2+y^2) formula로 누적
        # 반복 곱셈(모듈러 아님) -> (x_total, y_total) 에 누적
        # (x1 + i y1)*(x2 + i y2) = (x1*x2 - y1*y2) + i(x1*y2 + x2*y1)
        
        def complex_mul(x1, y1, x2, y2):
            return (x1*x2 - y1*y2, x1*y2 + x2*y1)
        
        cx, cy = 1, 0  # prime^exp 의 x,y
        bx, by = base_x, base_y
        
        for _ in range(exp):
            # 계속 곱
            nx, ny = complex_mul(cx, cy, bx, by)
            cx, cy = nx, ny
        
        # 이제 (cx, cy)를 (x_total, y_total)에 곱
        nx, ny = complex_mul(x_total, y_total, cx, cy)
        x_total, y_total = nx, ny
    
    # 최종 (x_total^2 + y_total^2) = c0
    return abs(x_total), abs(y_total)

try:
    u1, u2 = decompose_sum_of_squares(c0_factors)
    log.info(f"[2] (u1, u2) found: u1={u1}, u2={u2}")
except Exception as ex:
    log.warning("[2] Failed to factor c0 into x^2+y^2 properly. Need advanced approach.")
    raise

# ------------------------------------------------------------------------------
# step 3) n = p*q
#    p = next_prime( u1*base + r1 ), q = next_prime( u2*base + r2 )
#    base ~ 2^2048
#    r1,r2 ~ 최대 2^256
#
#  → Coppersmith (LLL)로 '부분적으로 알려진 큰 정수' 형태 인수분해를 시도.
#    여기서는 구현 예시가 매우 길어지므로, 간단히 'placeholder'만 넣음.
# ------------------------------------------------------------------------------
def factor_n_with_coppersmith(n, u1, u2):
    """
    실제로는:
      p ≈ u1 * base + small_1
      q ≈ u2 * base + small_2
    형태를 만족.
    - base ~ 2^2048 정도
    - small_1, small_2 ≤ 2^256

    Coppersmith / LLL 로 (p, q)를 찾아내는 코드가 필요.
    여기서는 '가짜'로 리턴만 해둠. 실제론 Sage 등에서 구현.
    """
    # TODO: 실제 구현 필수
    raise NotImplementedError("Coppersmith + LLL factorization is not implemented in this demo.")

try:
    p, q = factor_n_with_coppersmith(n, u1, u2)
    log.info(f"[3] p, q found:\n p={p}\n q={q}")
except NotImplementedError:
    log.error("Coppersmith / LLL 공격 구현이 필요합니다!")
    exit(1)

# ------------------------------------------------------------------------------
# step 4) RSA 복호화
#    - d = e^{-1} mod phi(n)
#    - m = c^d mod n
# ------------------------------------------------------------------------------
# 실제 코드는 아래 형태로 진행:
"""
phi = (p-1)*(q-1)
d = invert(e, phi)

pt_int = pow(c1, d, n)
pt = pt_int.to_bytes((pt_int.bit_length()+7)//8, 'big')
print("Decrypted:", pt)
"""

# 만약 p,q를 구했다고 가정하면 (위에서 factor_n_with_coppersmith로 성공했다 치고)
# 예시 형태:
"""
phi = (p-1)*(q-1)
d = invert(e, phi)
pt_int = pow(c1, d, n)
pt = pt_int.to_bytes((pt_int.bit_length()+7)//8, 'big')
log.success(f"[4] flag (plaintext) = {pt}")
"""

log.info("Exploit skeleton finished. (Implement the Coppersmith factor step!)")
